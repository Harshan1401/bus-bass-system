# bus_pass_demo.py
import os
import uuid
import datetime
from typing import Optional
from flask import Flask, request, jsonify, abort
from flask_sqlalchemy import SQLAlchemy
from passlib.hash import bcrypt
import jwt

# --------- Configuration (for demo only; in prod use env vars / secrets manager) ----------
SECRET_KEY = os.getenv("BUS_PASS_SECRET", "dev-secret-change-me")
JWT_ALGO = "HS256"
JWT_EXPIRE_MINUTES = 60 * 24  # demo: 1 day
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///bus_pass_demo.db")

# --------- App & DB init ----------------------------------------------------------------
app = Flask(__name__)
app.config["SQLALCHEMY_DATABASE_URI"] = DATABASE_URL
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
db = SQLAlchemy(app)

# --------- Models -----------------------------------------------------------------------
class User(db.Model):
    id = db.Column(db.String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    name = db.Column(db.String(120), nullable=False)
    email = db.Column(db.String(200), unique=True, nullable=False)
    phone = db.Column(db.String(50), nullable=True)
    password_hash = db.Column(db.String(255), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)

class Pass(db.Model):
    id = db.Column(db.String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    user_id = db.Column(db.String(36), db.ForeignKey("user.id"), nullable=True)
    pass_type = db.Column(db.String(32), nullable=False)  # single/weekly/monthly
    start_date = db.Column(db.DateTime, nullable=False)
    end_date = db.Column(db.DateTime, nullable=False)
    token = db.Column(db.String(128), unique=True, nullable=False)  # token for QR / validation
    status = db.Column(db.String(20), default="active")  # active/revoked/used
    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)

class ValidationLog(db.Model):
    id = db.Column(db.String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    pass_id = db.Column(db.String(36), db.ForeignKey("pass.id"), nullable=False)
    validated_by = db.Column(db.String(100), nullable=True)  # conductor id
    vehicle_id = db.Column(db.String(100), nullable=True)
    timestamp = db.Column(db.DateTime, default=datetime.datetime.utcnow)
    result = db.Column(db.String(20), nullable=False)  # accepted/rejected
    reason = db.Column(db.Text, nullable=True)

# --------- Utils ------------------------------------------------------------------------
def create_jwt(user_id: str):
    now = datetime.datetime.utcnow()
    payload = {
        "sub": user_id,
        "iat": now,
        "exp": now + datetime.timedelta(minutes=JWT_EXPIRE_MINUTES),
    }
    token = jwt.encode(payload, SECRET_KEY, algorithm=JWT_ALGO)
    return token

def decode_jwt(token: str) -> Optional[dict]:
    try:
        data = jwt.decode(token, SECRET_KEY, algorithms=[JWT_ALGO])
        return data
    except jwt.ExpiredSignatureError:
        return None
    except Exception:
        return None

def require_auth(fn):
    def wrapper(*args, **kwargs):
        auth = request.headers.get("Authorization", "")
        if not auth.startswith("Bearer "):
            return jsonify({"error": "missing auth"}), 401
        token = auth.split(" ", 1)[1]
        data = decode_jwt(token)
        if not data:
            return jsonify({"error": "invalid or expired token"}), 401
        request.user_id = data["sub"]
        return fn(*args, **kwargs)
    wrapper.__name__ = fn.__name__
    return wrapper

def gen_token():
    return uuid.uuid4().hex + uuid.uuid4().hex  # 64+ hex chars

# --------- Routes -----------------------------------------------------------------------
@app.route("/auth/register", methods=["POST"])
def register():
    payload = request.json or {}
    name = payload.get("name")
    email = payload.get("email")
    password = payload.get("password")
    phone = payload.get("phone")
    if not (name and email and password):
        return jsonify({"error": "name,email,password required"}), 400
    if User.query.filter_by(email=email).first():
        return jsonify({"error": "email in use"}), 400
    u = User(name=name, email=email, phone=phone, password_hash=bcrypt.hash(password))
    db.session.add(u)
    db.session.commit()
    token = create_jwt(u.id)
    return jsonify({"token": token, "user": {"id": u.id, "name": u.name, "email": u.email}})

@app.route("/auth/login", methods=["POST"])
def login():
    payload = request.json or {}
    email = payload.get("email")
    password = payload.get("password")
    if not (email and password):
        return jsonify({"error": "email,password required"}), 400
    u = User.query.filter_by(email=email).first()
    if not u or not bcrypt.verify(password, u.password_hash):
        return jsonify({"error": "invalid credentials"}), 401
    token = create_jwt(u.id)
    return jsonify({"token": token})

@app.route("/passes", methods=["POST"])
@require_auth
def create_pass():
    payload = request.json or {}
    pass_type = payload.get("pass_type", "single")
    # choose default durations
    start = datetime.datetime.utcnow()
    if pass_type == "single":
        end = start + datetime.timedelta(hours=4)  # single-ride valid for 4 hours (example)
    elif pass_type == "weekly":
        end = start + datetime.timedelta(days=7)
    elif pass_type == "monthly":
        end = start + datetime.timedelta(days=30)
    else:
        return jsonify({"error": "unknown pass_type"}), 400
    token = gen_token()
    p = Pass(user_id=request.user_id, pass_type=pass_type, start_date=start, end_date=end, token=token)
    db.session.add(p)
    db.session.commit()
    # In production, you'd generate a QR which encodes the token or pass_id
    return jsonify({
        "id": p.id,
        "token": p.token,
        "pass_type": p.pass_type,
        "start_date": p.start_date.isoformat(),
        "end_date": p.end_date.isoformat(),
        "status": p.status
    })

@app.route("/passes", methods=["GET"])
@require_auth
def list_passes():
    user_id = request.user_id
    ps = Pass.query.filter_by(user_id=user_id).order_by(Pass.created_at.desc()).all()
    out = []
    for p in ps:
        out.append({
            "id": p.id,
            "pass_type": p.pass_type,
            "start_date": p.start_date.isoformat(),
            "end_date": p.end_date.isoformat(),
            "status": p.status,
            "token": p.token
        })
    return jsonify(out)

@app.route("/validate", methods=["POST"])
def validate_pass():
    """
    Conductor/validator calls this endpoint with a token (from QR or typed)
    Body: { token, vehicle_id, conductor_id, location? }
    Returns accepted/rejected
    """
    payload = request.json or {}
    token = payload.get("token")
    vehicle_id = payload.get("vehicle_id")
    conductor_id = payload.get("conductor_id")
    if not token:
        return jsonify({"error": "token required"}), 400
    p = Pass.query.filter_by(token=token).first()
    if not p:
        # log rejection
        vl = ValidationLog(pass_id="unknown", validated_by=conductor_id, vehicle_id=vehicle_id, result="rejected", reason="not_found")
        db.session.add(vl); db.session.commit()
        return jsonify({"result": "rejected", "reason": "not_found"}), 404
    now = datetime.datetime.utcnow()
    if p.status != "active":
        reason = f"status_{p.status}"
        vl = ValidationLog(pass_id=p.id, validated_by=conductor_id, vehicle_id=vehicle_id, result="rejected", reason=reason)
        db.session.add(vl); db.session.commit()
        return jsonify({"result": "rejected", "reason": reason}), 403
    if not (p.start_date <= now <= p.end_date):
        reason = "expired_or_not_started"
        vl = ValidationLog(pass_id=p.id, validated_by=conductor_id, vehicle_id=vehicle_id, result="rejected", reason=reason)
        db.session.add(vl); db.session.commit()
        return jsonify({"result": "rejected", "reason": reason}), 403
    # accepted
    vl = ValidationLog(pass_id=p.id, validated_by=conductor_id, vehicle_id=vehicle_id, result="accepted")
    db.session.add(vl)
    # For single-ride passes you may want to mark them as used:
    if p.pass_type == "single":
        p.status = "used"
    db.session.commit()
    return jsonify({"result": "accepted", "pass_id": p.id})

@app.route("/health", methods=["GET"])
def health():
    return jsonify({"status": "ok"})

# --------- Initialize DB & Run -------------------------------------------------
if __name__ == "__main__":
    db.create_all()
    app.run(host="0.0.0.0", port=5000, debug=True)
